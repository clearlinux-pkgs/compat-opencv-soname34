From 351c5389378d82e5a96637fabad51b1b82947384 Mon Sep 17 00:00:00 2001
From: "Anselmo L. S. Melo" <anselmo.melo@intel.com>
Date: Sun, 15 Sep 2019 11:10:54 -0700
Subject: [PATCH] core(persistence): added null ptr checks #15145

Backport of
https://github.com/opencv/opencv/pull/15145/commits/5691d998ead1d9b0542bcfced36c2dceb3a59023
by Alexander Alekhin <alexander.alekhin@intel.com>
---
 modules/core/src/persistence_json.cpp | 13 +++++++++++++
 modules/core/src/persistence_xml.cpp  | 23 +++++++++++++++++++++++
 modules/core/src/persistence_yml.cpp  | 22 ++++++++++++++++++++++
 3 files changed, 58 insertions(+)

diff --git a/modules/core/src/persistence_json.cpp b/modules/core/src/persistence_json.cpp
index 1ed6321..2946962 100644
--- a/modules/core/src/persistence_json.cpp
+++ b/modules/core/src/persistence_json.cpp
@@ -18,6 +18,8 @@ icvJSONSkipSpaces( CvFileStorage* fs, char* ptr )
 
     while ( is_eof == false && is_completed == false )
     {
+        if (!ptr)
+            CV_PARSE_ERROR("Invalid input");
         switch ( *ptr )
         {
         /* comment */
@@ -103,6 +105,7 @@ icvJSONSkipSpaces( CvFileStorage* fs, char* ptr )
     if ( is_eof )
     {
         ptr = fs->buffer_start;
+        CV_Assert(ptr);
         *ptr = '\0';
         fs->dummy_eof = 1;
     }
@@ -119,6 +122,9 @@ icvJSONSkipSpaces( CvFileStorage* fs, char* ptr )
 
 static char* icvJSONParseKey( CvFileStorage* fs, char* ptr, CvFileNode* map, CvFileNode** value_placeholder )
 {
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
+
     if( *ptr != '"' )
         CV_PARSE_ERROR( "Key must start with \'\"\'" );
 
@@ -161,6 +167,9 @@ static char* icvJSONParseKey( CvFileStorage* fs, char* ptr, CvFileNode* map, CvF
 
 static char* icvJSONParseValue( CvFileStorage* fs, char* ptr, CvFileNode* node )
 {
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid value input");
+
     ptr = icvJSONSkipSpaces( fs, ptr );
     if ( ptr == 0 || fs->dummy_eof )
         CV_PARSE_ERROR( "Unexpected End-Of-File" );
@@ -562,6 +571,10 @@ static char* icvJSONParseMap( CvFileStorage* fs, char* ptr, CvFileNode* node )
 void icvJSONParse( CvFileStorage* fs )
 {
     char* ptr = fs->buffer_start;
+
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
+
     ptr = icvJSONSkipSpaces( fs, ptr );
     if ( ptr == 0 || fs->dummy_eof )
         return;
diff --git a/modules/core/src/persistence_xml.cpp b/modules/core/src/persistence_xml.cpp
index 276eb78..b09996e 100644
--- a/modules/core/src/persistence_xml.cpp
+++ b/modules/core/src/persistence_xml.cpp
@@ -23,6 +23,9 @@
 static char*
 icvXMLSkipSpaces( CvFileStorage* fs, char* ptr, int mode )
 {
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
+
     int level = 0;
 
     for(;;)
@@ -191,6 +194,9 @@ static char*
 icvXMLParseValue( CvFileStorage* fs, char* ptr, CvFileNode* node,
                   int value_type CV_DEFAULT(CV_NODE_NONE))
 {
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
+
     CvFileNode *elem = node;
     bool have_space = true, is_simple = true;
     int is_user_type = CV_NODE_IS_USER(value_type);
@@ -206,6 +212,8 @@ icvXMLParseValue( CvFileStorage* fs, char* ptr, CvFileNode* node,
         if( cv_isspace(c) || c == '\0' || (c == '<' && ptr[1] == '!' && ptr[2] == '-') )  // FIXIT ptr[1], ptr[2] - out of bounds read without check or data fetch (#11061)
         {
             ptr = icvXMLSkipSpaces( fs, ptr, 0 );
+            if (!ptr)
+                CV_PARSE_ERROR("Invalid input");
             have_space = true;
             c = *ptr;
         }
@@ -279,6 +287,8 @@ icvXMLParseValue( CvFileStorage* fs, char* ptr, CvFileNode* node,
                 /* for base64 string */
                 ptr = icvXMLParseBase64( fs, ptr, elem);
                 ptr = icvXMLSkipSpaces( fs, ptr, 0 );
+                if (!ptr)
+                    CV_PARSE_ERROR("Invalid input");
             }
 
             if( !is_noname )
@@ -461,6 +471,9 @@ icvXMLParseTag( CvFileStorage* fs, char* ptr, CvStringHashNode** _tag,
     char c;
     int have_space;
 
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid tag input");
+
     if( *ptr == '\0' )
         CV_PARSE_ERROR( "Preliminary end of the stream" );
 
@@ -536,6 +549,8 @@ icvXMLParseTag( CvFileStorage* fs, char* ptr, CvStringHashNode** _tag,
             if( *ptr != '=' )
             {
                 ptr = icvXMLSkipSpaces( fs, ptr, CV_XML_INSIDE_TAG );
+                if (!ptr)
+                    CV_PARSE_ERROR("Invalid attribute");
                 if( *ptr != '=' )
                     CV_PARSE_ERROR( "Attribute name should be followed by \'=\'" );
             }
@@ -560,6 +575,8 @@ icvXMLParseTag( CvFileStorage* fs, char* ptr, CvStringHashNode** _tag,
         if( c != '>' )
         {
             ptr = icvXMLSkipSpaces( fs, ptr, CV_XML_INSIDE_TAG );
+            if (!ptr)
+                CV_PARSE_ERROR("Invalid input");
             c = *ptr;
         }
 
@@ -599,12 +616,16 @@ icvXMLParseTag( CvFileStorage* fs, char* ptr, CvStringHashNode** _tag,
 void icvXMLParse( CvFileStorage* fs )
 {
     char* ptr = fs->buffer_start;
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
     CvStringHashNode *key = 0, *key2 = 0;
     CvAttrList* list = 0;
     int tag_type = 0;
 
     // CV_XML_INSIDE_TAG is used to prohibit leading comments
     ptr = icvXMLSkipSpaces( fs, ptr, CV_XML_INSIDE_TAG );
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
 
     if( memcmp( ptr, "<?xml", 5 ) != 0 )  // FIXIT ptr[1..] - out of bounds read without check
         CV_PARSE_ERROR( "Valid XML should start with \'<?xml ...?>\'" );
@@ -629,6 +650,8 @@ void icvXMLParse( CvFileStorage* fs )
     while( *ptr != '\0' )
     {
         ptr = icvXMLSkipSpaces( fs, ptr, 0 );
+        if (!ptr)
+            CV_PARSE_ERROR("Invalid input");
 
         if( *ptr != '\0' )
         {
diff --git a/modules/core/src/persistence_yml.cpp b/modules/core/src/persistence_yml.cpp
index f4cc6e4..89db5ae 100644
--- a/modules/core/src/persistence_yml.cpp
+++ b/modules/core/src/persistence_yml.cpp
@@ -15,6 +15,9 @@
 
 static char* icvYMLSkipSpaces( CvFileStorage* fs, char* ptr, int min_indent, int max_comment_indent )
 {
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
+
     for(;;)
     {
         while( *ptr == ' ' )
@@ -63,6 +66,9 @@ static char* icvYMLSkipSpaces( CvFileStorage* fs, char* ptr, int min_indent, int
 
 static void icvYMLGetMultilineStringContent(CvFileStorage* fs, char* ptr, int indent, char* &beg, char* &end)
 {
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
+
     ptr = icvYMLSkipSpaces(fs, ptr, 0, INT_MAX);
     beg = ptr;
     end = ptr;
@@ -148,6 +154,9 @@ static char* icvYMLParseBase64(CvFileStorage* fs, char* ptr, int indent, CvFileN
 
 static char* icvYMLParseKey( CvFileStorage* fs, char* ptr, CvFileNode* map_node, CvFileNode** value_placeholder )
 {
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
+
     char c;
     char *endptr = ptr - 1, *saveptr;
     CvStringHashNode* str_hash_node;
@@ -181,6 +190,9 @@ static char*
 icvYMLParseValue( CvFileStorage* fs, char* ptr, CvFileNode* node,
                   int parent_flags, int min_indent )
 {
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
+
     char buf[CV_FS_MAX_LEN + 1024] = {0};
     char* endptr = 0;
     char c = ptr[0], d = ptr[1];
@@ -274,6 +286,8 @@ icvYMLParseValue( CvFileStorage* fs, char* ptr, CvFileNode* node,
 
         *endptr = d;
         ptr = icvYMLSkipSpaces( fs, endptr, min_indent, INT_MAX );
+        if (!ptr)
+            CV_PARSE_ERROR("Invalid input");
 
         c = *ptr;
 
@@ -411,6 +425,8 @@ force_int:
             CvFileNode* elem = 0;
 
             ptr = icvYMLSkipSpaces( fs, ptr, new_min_indent, INT_MAX );
+            if (!ptr)
+                CV_PARSE_ERROR("Invalid input");
             if( *ptr == '}' || *ptr == ']' )
             {
                 if( *ptr != d )
@@ -424,6 +440,8 @@ force_int:
                 if( *ptr != ',' )
                     CV_PARSE_ERROR( "Missing , between the elements" );
                 ptr = icvYMLSkipSpaces( fs, ptr + 1, new_min_indent, INT_MAX );
+                if (!ptr)
+                    CV_PARSE_ERROR("Invalid input");
             }
 
             if( CV_NODE_IS_MAP(struct_flags) )
@@ -540,6 +558,10 @@ force_string:
 void icvYMLParse( CvFileStorage* fs )
 {
     char* ptr = fs->buffer_start;
+
+    if (!ptr)
+        CV_PARSE_ERROR("Invalid input");
+
     int is_first = 1;
 
     for(;;)
-- 
2.23.0

